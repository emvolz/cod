[{"path":"https://emvolz.github.io/cod/articles/ngono.html","id":"estimating-coalescent-odds","dir":"Articles","previous_headings":"","what":"Estimating coalescent odds","title":"Neisseria gonorrheae: Computing coalescent odds, identifying growing lineages, cluster identification & sample reweighting","text":"main function estimate coalescent odds using weighted least squares codls: required argument time-scaled phylogenetic tree. method models correlation coalescent odds phylogenetic lineages using Gaussian-Markov Random Field includes precision parameter logtau. independently estimated, can provided codls speed estimation, omitted, logtau automatically estimated using optcodsmooth function. can also speed codls using multiple CPUs ncpu argument. Plotting fit display tree estimated log odds coalescence mapped colour branches. Note requires ggtree package installed.  coalescent odds branch can retrieved using coef, e.g.: order nodes input tree. Let’s merge estimated coalescent odds back metadata subsequent analysis:","code":"f <- codls( tr ) f ##  Genealogical placement GMRF model fit  ##  ## Phylogenetic tree with 1102 tips and 1101 internal nodes. ##  ## Tip labels: ##   17176_1#21, 15335_3#33, 15335_6#51, 15335_4#63, 15335_5#50, 8727_8#36, ... ##  ## Rooted; includes branch length(s). ## Range of coefficients:  ## -1.12889544705052 1.9085811316829 ## Precision parameter (log tau): 2.17220420767149 # Plot the tree with coalescent odds - handle potential ggtree issues tryCatch({   plot(f) }, error = function(e) {   cat(\"Plot generation failed due to ggtree compatibility issue:\\n\")   cat(e$message, \"\\n\")   cat(\"Tree summary:\\n\")   print(f)   cat(\"\\nCoalescent odds summary:\\n\")   print(summary(coef(f))) }) coef(f)[1:4] ## [1] 0.004858235 0.104878380 0.145474704 0.203367462 fdf <- data.frame( tip = f$data$tip.label, psi = coef(f)[1:Ntip(tr)] ) md$tip  <- md$ID  md <- merge( md, fdf, by = 'tip') head( md ) ##          tip         ID PEN TET SPC CFX CRO CIP AZI Clinic Year        psi ## 1  15335_2#1  15335_2#1   2   2   0   2   0   2   1    POR 2012 -0.4367199 ## 2 15335_2#10 15335_2#10   1   1   0   0   0   0   2    MIN 2005  0.2358685 ## 3 15335_2#11 15335_2#11   1   1   0   0   0   0   2    MIN 2005  0.2036033 ## 4 15335_2#12 15335_2#12   1   2   0   0   0   0   2    LVG 2006  0.1989217 ## 5 15335_2#13 15335_2#13   2   2   0  NA   0   2   2    CHI 2008 -0.2859137 ## 6 15335_2#14 15335_2#14   2   2   0  NA   0   0   2    KCY 2008 -0.2889254"},{"path":"https://emvolz.github.io/cod/articles/ngono.html","id":"sample-weights","dir":"Articles","previous_headings":"","what":"Sample weights","title":"Neisseria gonorrheae: Computing coalescent odds, identifying growing lineages, cluster identification & sample reweighting","text":"examine relationship coalescent odds samples originated (Clinic) clinics significantly higher values: possible occurred locations sampled intensively clinics can artificially increase coalescent rates higher local density co-circulating lineages. Samples can -weighted codls passing *weights* argument, ameliorate bias -sampling know much -sampling took place. Unfortunately, rarely known, cod includes routine consider range sample weights identify maximum weight longer significant relationship coalescent odds given variable (usually geographic). identify samples “MIA” clinical pass autoreweight function. Note cases, association disappear even weight zero lineages surrounding given samples also higher coalescent odds. cases, relationship likely authentic. exactly see . Even weighting samples 1% (unrealistically low) remains significant association coalescent odds. Consequently, fit identical original fit.","code":"table( md$Clinic ) |> sort() ##  ## COL LA2 SLC STL FBG GRB IND PON NOR LBC NYC CLE RIC KCY ALB DTR OKC DAL CIN ATL  ##   3   3   3   3   4   6   6   6   7   8   8  11  11  13  14  14  14  16  22  25  ## BHM MIA SEA DEN BAL HON POR MIN LAX ORA PHX SFO PHI CHI LVG SDG  ##  28  28  29  30  33  35  48  51  53  62  64  67  69  71  85 152 s <- lm( psi ~ Clinic, data = md) |> summary()  s ##  ## Call: ## lm(formula = psi ~ Clinic, data = md) ##  ## Residuals: ##      Min       1Q   Median       3Q      Max  ## -1.17016 -0.31795 -0.08085  0.14890  1.88243  ##  ## Coefficients: ##             Estimate Std. Error t value Pr(>|t|)    ## (Intercept) -0.08706    0.15173  -0.574  0.56624    ## ClinicATL    0.08569    0.18951   0.452  0.65125    ## ClinicBAL    0.19265    0.18107   1.064  0.28760    ## ClinicBHM   -0.06594    0.18583  -0.355  0.72277    ## ClinicCHI    0.15978    0.16601   0.962  0.33604    ## ClinicCIN   -0.15816    0.19409  -0.815  0.41531    ## ClinicCLE   -0.14502    0.22874  -0.634  0.52622    ## ClinicCOL   -0.13869    0.36118  -0.384  0.70107    ## ClinicDAL    0.36634    0.20776   1.763  0.07814 .  ## ClinicDEN   -0.01967    0.18375  -0.107  0.91479    ## ClinicDTR    0.03101    0.21457   0.144  0.88513    ## ClinicFBG   -0.10919    0.32186  -0.339  0.73450    ## ClinicGRB    0.78823    0.27701   2.845  0.00452 ** ## ClinicHON    0.06508    0.17952   0.363  0.71704    ## ClinicIND    0.08834    0.27701   0.319  0.74987    ## ClinicKCY    0.08874    0.21866   0.406  0.68494    ## ClinicLA2    0.63990    0.36118   1.772  0.07673 .  ## ClinicLAX    0.12362    0.17059   0.725  0.46882    ## ClinicLBC   -0.18841    0.25161  -0.749  0.45414    ## ClinicLVG   -0.09778    0.16374  -0.597  0.55055    ## ClinicMIA    0.43854    0.18583   2.360  0.01846 *  ## ClinicMIN    0.05422    0.17129   0.317  0.75163    ## ClinicNOR   -0.24982    0.26280  -0.951  0.34201    ## ClinicNYC   -0.18111    0.25161  -0.720  0.47180    ## ClinicOKC   -0.25290    0.21457  -1.179  0.23881    ## ClinicORA    0.14291    0.16799   0.851  0.39512    ## ClinicPHI    0.09847    0.16641   0.592  0.55414    ## ClinicPHX    0.23628    0.16750   1.411  0.15865    ## ClinicPON    0.24875    0.27701   0.898  0.36940    ## ClinicPOR    0.09572    0.17244   0.555  0.57896    ## ClinicRIC   -0.10540    0.22874  -0.461  0.64503    ## ClinicSDG    0.14276    0.15856   0.900  0.36813    ## ClinicSEA   -0.10906    0.18475  -0.590  0.55510    ## ClinicSFO   -0.02538    0.16683  -0.152  0.87910    ## ClinicSLC   -0.27095    0.36118  -0.750  0.45331    ## ClinicSTL   -0.19067    0.36118  -0.528  0.59766    ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Residual standard error: 0.5677 on 1066 degrees of freedom ## Multiple R-squared:  0.06646,    Adjusted R-squared:  0.0358  ## F-statistic: 2.168 on 35 and 1066 DF,  p-value: 0.0001154 # Clinics associated with psi : signifclinics <- rownames(s$coefficients)[ s$coefficients[ , 4]  < .1 ] signifclinics <- substr(signifclinics, 7,9 ) # Subset of tips from clinics associated with psi : reweighttips  <- md$tip[ md$Clinic %in% signifclinics ] arw <- autoreweight( f, reweighttips, wlb = 1e-2, wub = .5, res = 5, alpha = .02 ) f = arw$fit arw$summary ##   sampleweight            p ## 1       0.0100 0.0182876306 ## 2       0.1325 0.0060415712 ## 3       0.2550 0.0018345749 ## 4       0.3775 0.0005179955 ## 5       0.5000 0.0001375240"},{"path":"https://emvolz.github.io/cod/articles/ngono.html","id":"antibiotic-resistance","dir":"Articles","previous_headings":"","what":"Antibiotic resistance","title":"Neisseria gonorrheae: Computing coalescent odds, identifying growing lineages, cluster identification & sample reweighting","text":"examine relationship coalescent odds antibiotic resistance. First, replot coloured tree alongside resistance phenotypes.  looks like higher coalescent odds associated AZI resistance abx shows positive effect. Let’s quantify . linear regression coalescent odds abx time, infer mean psi end sampling (year 2013). result plotted:  fact, resistance AZI expanded rapidly data collected, prevalence 0.6% 2013 4.5% 20173. rapid growth among antibiotics.","code":"abxs <- c( 'PEN', 'TET', 'CFX', 'CRO', 'CIP', 'AZI') abxmat <- as.matrix(md[, abxs ] ) abxmat <- apply( abxmat, 2, function(x) (x == \"2\") ) # The value of '2' is coded as abx resistant rownames( abxmat ) <- md$tip  head(abxmat) ##              PEN   TET   CFX   CRO   CIP   AZI ## 15335_2#1   TRUE  TRUE  TRUE FALSE  TRUE FALSE ## 15335_2#10 FALSE FALSE FALSE FALSE FALSE  TRUE ## 15335_2#11 FALSE FALSE FALSE FALSE FALSE  TRUE ## 15335_2#12 FALSE  TRUE FALSE FALSE FALSE  TRUE ## 15335_2#13  TRUE  TRUE    NA FALSE  TRUE  TRUE ## 15335_2#14  TRUE  TRUE    NA FALSE FALSE  TRUE abxmat[ is.na(abxmat) ] <- FALSE  # Try to create tree plot with heatmap, handle ggtree issues tryCatch({   trpl <- plot(f) +      ggplot2::scale_color_gradient2( low='blue'                                   , mid = 'lightblue'                                   , high = 'red'                                   , midpoint = 0                                   , limits = range(fdf$psi)                                   , name = \"ψ\" )   trpl <- ggtree::gheatmap( trpl, abxmat, colnames_position='top', colnames_offset_y = -11)   trpl$data$label = '' # suppress tip labels    print(trpl) }, error = function(e) {   cat(\"Tree plot with heatmap failed due to ggtree compatibility issue:\\n\")   cat(e$message, \"\\n\")   cat(\"\\nAntibiotic resistance summary:\\n\")   print(colSums(abxmat))   cat(\"\\nSamples with highest coalescent odds:\\n\")   top_psi <- head(md[order(md$psi, decreasing=TRUE), c(\"tip\", \"psi\", abxs)], 10)   print(top_psi) }) md$t  <- md$Year - min(md$Year) psi2013 <- sapply( abxs, function(x) {     md1 <- md     md1$v <- md1[[x]] == 2     m = lm( psi ~ v*t  , data = md1 )     predict( m, newdata= data.frame( psi = NA, v = TRUE, t = 13 ) , interval='confidence') }) |> setNames( abxs ) ebdf <- as.data.frame( t( psi2013 ) )  colnames(ebdf) <- c( 'Median', '2.5%', '97.5%' ) ebdf$abx = rownames( ebdf )  ebdf <- ebdf[ order( ebdf$Median ) , ]  print( ebdf ) ##          Median        2.5%       97.5% abx ## CRO -0.33689489 -1.01640541  0.34261563 CRO ## PEN -0.13405015 -0.20522152 -0.06287877 PEN ## CIP -0.13023070 -0.19953996 -0.06092143 CIP ## CFX -0.02911709 -0.15417258  0.09593839 CFX ## TET  0.02391297 -0.04309963  0.09092558 TET ## AZI  0.89029502  0.77634421  1.00424584 AZI peb = ggplot2::ggplot(ebdf, ggplot2::aes(x = abx, y = Median, ymin = `2.5%`, ymax = `97.5%`) ) + ggplot2::geom_errorbar(width=0) +  ggplot2::geom_point() +  ggplot2::labs(y = 'psi', x = '' ) peb"},{"path":"https://emvolz.github.io/cod/articles/ngono.html","id":"phylogenetic-clusters","dir":"Articles","previous_headings":"","what":"Phylogenetic clusters","title":"Neisseria gonorrheae: Computing coalescent odds, identifying growing lineages, cluster identification & sample reweighting","text":"alternative way look coalescent odds terms phylogenetic clusters. clades defined threshold change coalescent odds along lineage, low high values. subjectivity choice clustering thresholds best choice depends application, however cod provides method based Calinski-Harabasz index. , compute clusters using maximum CH index. Note threshold provided, computeclusters automatically select optimal threshold: Plotting shows one cluster closely matches clade high levels AZI resistance high coalescent odds, alternative way analyse data identify clusters high coalescent odds characterise resistance patters within clusters. clusters can visualised running plotclusters(f, chdf).","code":"chis <- chindices(f, clths = seq( .03, .4, length = 20 ), rescale=TRUE) chis ##     threshold         CH optimal ## 1  0.03000000   3111.261         ## 2  0.04947368   6462.252         ## 3  0.06894737  10778.941         ## 4  0.08842105  14680.318         ## 5  0.10789474  21507.628         ## 6  0.12736842  29094.522         ## 7  0.14684211  29271.671         ## 8  0.16631579  37338.379         ## 9  0.18578947  46129.976         ## 10 0.20526316  56708.829         ## 11 0.22473684  59308.878         ## 12 0.24421053  58146.264         ## 13 0.26368421  72607.117         ## 14 0.28315789  62908.156         ## 15 0.30263158  67294.613         ## 16 0.32210526  81134.673         ## 17 0.34157895  96503.181         ## 18 0.36105263 117905.819         ## 19 0.38052632 126070.206         ## 20 0.40000000 160636.312     *** # Using optimal threshold from CH index chdf = computeclusters(f, chis$threshold[which.max(chis$CH)] ) # Alternatively, let computeclusters automatically select optimal threshold: # chdf = computeclusters(f)   head(chdf) ##   node  tip.label clusterid        psi  tip ## 1  986 15335_2#43         1 -0.2610328 TRUE ## 2  987 15335_4#44         1 -0.2610328 TRUE ## 3  988 15335_4#19         1 -0.2565474 TRUE ## 4  989 17225_3#73         1 -0.2204023 TRUE ## 5  990 17176_1#34         1 -0.2171693 TRUE ## 6  991 17225_3#89         1 -0.2582032 TRUE # Cluster summary statistics cat(\"Cluster summary:\\n\") ## Cluster summary: print(table(chdf$clusterid)) ##  ##   1   2   3   4   5   6   7   8   9  10  11  12  13  14  ##  22 104  88  92   4 192   3 140  47 141   3 575 308 616 cat(\"\\nCluster statistics (coalescent odds by cluster):\\n\") ##  ## Cluster statistics (coalescent odds by cluster): cluster_stats <- aggregate(chdf$psi, by=list(chdf$clusterid),                            function(x) c(mean=mean(x, na.rm=TRUE),                                        sd=sd(x, na.rm=TRUE),                                        n=length(x))) names(cluster_stats) <- c(\"cluster\", \"psi_stats\") print(cluster_stats) ##    cluster psi_stats.mean  psi_stats.sd   psi_stats.n ## 1        1   -0.341212048   0.171619309  22.000000000 ## 2        2    0.381617700   0.254668680 104.000000000 ## 3        3    0.363007212   0.214765365  88.000000000 ## 4        4   -0.175488735   0.208121259  92.000000000 ## 5        5   -0.887119967   0.144975491   4.000000000 ## 6        6    1.548975084   0.213336390 192.000000000 ## 7        7    0.710763879   0.199858674   3.000000000 ## 8        8    0.084002855   0.138217162 140.000000000 ## 9        9   -0.221995933   0.121345282  47.000000000 ## 10      10   -0.224530136   0.166636298 141.000000000 ## 11      11   -0.655195021   0.272068455   3.000000000 ## 12      12   -0.206051956   0.192692458 575.000000000 ## 13      13    0.003235142   0.383942098 308.000000000 ## 14      14   -0.286349103   0.293983310 616.000000000"},{"path":[]},{"path":"https://emvolz.github.io/cod/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Erik Volz. Maintainer.","code":""},{"path":"https://emvolz.github.io/cod/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Volz E (2025). cod: Inference Coalescent ODds Phylogenetic Trees. R package version 0.8.0, https://emvolz.github.io/cod/.","code":"@Manual{,   title = {cod: Inference of Coalescent ODds in Phylogenetic Trees},   author = {Erik Volz},   year = {2025},   note = {R package version 0.8.0},   url = {https://emvolz.github.io/cod/}, }"},{"path":[]},{"path":"https://emvolz.github.io/cod/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"cod R package provides tools inferring variation coalescent rates across branches phylogenetic trees. provides methods identify growing lineages, adjust biased sampling, compute phylogenetic clusters, optimize cluster thresholds, summarize rate variations. worked examples detailed usage, see package documentation vigettes https://emvolz.github.io/cod/.","code":""},{"path":"https://emvolz.github.io/cod/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"can install cod GitHub using devtools:","code":"# install.packages(\"devtools\") devtools::install_github(\"emvolz/cod\")"},{"path":"https://emvolz.github.io/cod/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"package requires several dependencies: - Matrix (>= 1.7) - ape (>= 5.0) - glue (>= 1.0.0) - mgcv (>= 1.9-1) - parallel Optional packages visualization: - ggtree (>= 3.12.0) - ggplot2 (>= 3.0.0)","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/index.html","id":"estimating-coalescent-odds","dir":"","previous_headings":"Key Features","what":"Estimating Coalescent Odds","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"main function codls() estimates coalescent odds using weighted least squares:","code":"# Load a phylogenetic tree tr <- ape::read.tree(\"your_tree_file.nwk\")  # Fit the COD GMRF model f <- codls(tr)  # View summary summary(f)  # Plot the results (requires ggtree) plot(f)"},{"path":"https://emvolz.github.io/cod/index.html","id":"phylogenetic-clustering","dir":"","previous_headings":"Key Features","what":"Phylogenetic Clustering","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"Identify clusters phylogenetic trees based coalescent odds:","code":"# Find optimal clustering threshold chis <- chindices(f, clths = seq(0.1, 1.5, length = 20))  # Compute clusters clusterdf <- computeclusters(f, clth = chis$threshold[which.max(chis$CH)])  # Plot clusters (requires ggtree) plotclusters(f, clusterdf)"},{"path":"https://emvolz.github.io/cod/index.html","id":"adjusting-for-sampling-bias","dir":"","previous_headings":"Key Features","what":"Adjusting for Sampling Bias","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"Correct biased sampling using sample reweighting method:","code":"# Identify tips to reweight reweight_tips <- c(\"tip1\", \"tip2\", \"tip3\")  # Automatically determine optimal reweighting reweightedfit <- autoreweight(f, reweight_tips)"},{"path":"https://emvolz.github.io/cod/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"detailed documentation functions parameters, use R help system vignettes:","code":"?codls ?computeclusters ?autoreweight"},{"path":"https://emvolz.github.io/cod/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"manuscript describing methods package currently preparation.","code":""},{"path":"https://emvolz.github.io/cod/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"package available MIT License. See LICENSE file information.","code":""},{"path":"https://emvolz.github.io/cod/reference/autoreweight.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically reweight sample units that may be oversampled — autoreweight","title":"Automatically reweight sample units that may be oversampled — autoreweight","text":"Given fit `codls` set samples suspected -sampling, function re-compute `codls` range reweighted samples. identify sample weight association lost coalescent odds (psi) given set samples. appropriate weight use association coalescent odds psi due sampling effects due evolutionary effects, note method may mask evolutionary effects present.","code":""},{"path":"https://emvolz.github.io/cod/reference/autoreweight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically reweight sample units that may be oversampled — autoreweight","text":"","code":"autoreweight(f, rwtips, wlb = 0.01, wub = 0.5, res = 10, alpha = 0.05)"},{"path":"https://emvolz.github.io/cod/reference/autoreweight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically reweight sample units that may be oversampled — autoreweight","text":"f `codls` fit rwtips Vector samples (type character) suspected -sampling wlb Numeric lower bound sample weights examine wub Numeric upper bound sample weights examine res Integer number weights examine alpha p value threshold used selecting optimal weight","code":""},{"path":"https://emvolz.github.io/cod/reference/autoreweight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically reweight sample units that may be oversampled — autoreweight","text":"list components `fit`: reweigthed `codls` fit; `weights`: new vector sample weights; `optimalweight` scalar weight applied oversampled units; `summary`: data frame showing regression p values range weights","code":""},{"path":"https://emvolz.github.io/cod/reference/chindex.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the CH index for selecting clustering thresholds — chindex","title":"Computes the CH index for selecting clustering thresholds — chindex","text":"Computes CH index selecting clustering thresholds","code":""},{"path":"https://emvolz.github.io/cod/reference/chindex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the CH index for selecting clustering thresholds — chindex","text":"","code":"chindex(clusterdf)"},{"path":"https://emvolz.github.io/cod/reference/chindex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the CH index for selecting clustering thresholds — chindex","text":"clusterdf Output `computeclusters`","code":""},{"path":"https://emvolz.github.io/cod/reference/chindices.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute CH index over a range of clustering thresholds — chindices","title":"Compute CH index over a range of clustering thresholds — chindices","text":"Compute CH index range clustering thresholds","code":""},{"path":"https://emvolz.github.io/cod/reference/chindices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute CH index over a range of clustering thresholds — chindices","text":"","code":"chindices(f, clths = seq(0.1, 1.5, length = 20), rescale = TRUE)"},{"path":"https://emvolz.github.io/cod/reference/chindices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute CH index over a range of clustering thresholds — chindices","text":"f fit `codls` clths Numeric vector clustering thresholds rescale Passed `computeclusters`","code":""},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"Fits COD GMRF model using `mgcv::gam` method. Additional arguments can passed `gam`; see documentation method. Using method=\"REML\" can speed execution using constrained maximum likelihood approach. Additionally, approximate reduced-rank MRF model can fitted supplying `k` parameter. tau provided, `codls` also used optimise parameter. method slower `codls` recommended trees several hundred samples.","code":""},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"","code":"codbinomial(tr1, logtau = NULL, k = Inf, profcontrol = list(), ...)"},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"tr1 Phylogenetic tree ape::phylo format logtau Precision parameter. NULL, invoke `tauprofile` find best value. k Fits reduced-rank MRF model k integer < number nodes input tree. can speed calculation reduces precision. profcontrol Optional list arguments passed `tauprofile` ... Additional arguments passed `mgcv::gam`","code":""},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"COD GMRF model fit. Includes GAM model fit.","code":""},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"ML COD GMRF method currently support inverse probability weighting samples. Use `codls` sample weighting needed.","code":""},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a COD GMRF model using weighted least squares — codls","title":"Fit a COD GMRF model using weighted least squares — codls","text":"Fit COD GMRF model using weighted least squares","code":""},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a COD GMRF model using weighted least squares — codls","text":"","code":"codls(tr1, logtau = NULL, profcontrol = list(), weights = NULL, ncpu = 1)"},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a COD GMRF model using weighted least squares — codls","text":"tr1 Phylogenetic tree ape::phylo format logtau Precision parameter. NULL, invoke `tauprofile` find best value. profcontrol Optional list arguments passed `tauprofile` weights optional vector (named unnamed) sample weights tip input tree ncpu Integer number cpu's use parallel calculation tau profile desired","code":""},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a COD GMRF model using weighted least squares — codls","text":"COD GMRF model fit","code":""},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a COD GMRF model using weighted least squares — codls","text":"","code":"# A simple example that does not have population structure  set.seed( 1111 ) tr <- ape::rtree( 100 ) f <- codls(tr) #> c(-4, 0.0999999999999996, 4.2, 8.3, 12.4, 16.5, 20.6, 24.7, 28.8, 32.9, 37)c(839.610222117401, 372.398296997339, 345.306824047442, 345.280902945219, 345.28089580974, 345.28089580778, Inf, Inf, Inf, Inf, Inf)c(\"\", \"\", \"\", \"\", \"\", \"***\", \"\", \"\", \"\", \"\", \"\") #> Warning: Inf replaced by maximum positive value #> Warning: Inf replaced by maximum positive value #> Warning: Inf replaced by maximum positive value #> c(-4, 0.0999999999999996, 4.2, 8.3, 12.4, 16.5, 20.6, 24.7, 28.8, 32.9, 37)c(839.610222117401, 372.398296997339, 345.306824047442, 345.280902945219, 345.28089580974, 345.28089580778, Inf, Inf, Inf, Inf, Inf)c(\"\", \"\", \"\", \"\", \"\", \"***\", \"\", \"\", \"\", \"\", \"\") coef(f) |> head()  #> [1] -3.640017e-14 -3.132941e-14 -3.446806e-14 -3.171095e-14 -4.953729e-14 #> [6] -4.956475e-14 summary(f) #>  Genealogical placement GMRF model fit  #>  #> Phylogenetic tree with 100 tips and 99 internal nodes. #>  #> Tip labels: #>   t13, t36, t48, t79, t65, t66, ... #>  #> Rooted; includes branch length(s). #> Range of coefficients:  #> -7.19882172734318e-14 8.88092382524843e-14 #> Precision parameter (log tau): 16.761414287381  #>  #>   logprecision       RMSCLO Neff #> 1     16.76141 4.240497e-14  100 #>  if (FALSE) { # \\dontrun{ plot(f) } # }  # This example has population structure  tr0 = rcoal(20); tr0$edge.length <- .01*tr0$edge.length  tr1 = rcoal(80);  dx <- (max(node.depth.edgelength( tr1 ))-max(node.depth.edgelength( tr0 ))) tr0$root.edge <- dx tr <- bind.tree(tr0,tr1, position = dx) f <- codls(tr) #> c(-4, 0.0999999999999996, 4.2, 8.3, 12.4, 16.5, 20.6, 24.7, 28.8, 32.9, 37)c(3743.24780055663, 3210.78459384594, 3228.34397023542, 3228.61108342026, 3228.61307940198, Inf, 3228.569943925, 3228.569943925, Inf, Inf, Inf)c(\"\", \"***\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\") #> c(-4, 0.0999999999999996, 4.2, 8.3, 12.4, 16.5, 20.6, 24.7, 28.8, 32.9, 37)c(3743.24780055663, 3210.78459384594, 3228.34397023542, 3228.61108342026, 3228.61307940198, Inf, 3228.569943925, 3228.569943925, Inf, Inf, Inf)c(\"\", \"***\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\") summary(f)  #>  Genealogical placement GMRF model fit  #>  #> Phylogenetic tree with 100 tips and 98 internal nodes. #>  #> Tip labels: #>   t18, t1, t16, t9, t7, t11, ... #>  #> Rooted; includes branch length(s). #> Range of coefficients:  #> -0.548001884420184 1.15812937469376 #> Precision parameter (log tau): 0.83441648702799  #>  #>   logprecision    RMSCLO     Neff #> 1    0.8344165 0.5697688 92.94934 #>  if (FALSE) { # \\dontrun{ plot(f) } # }"},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a genealogical placement GMRF model using maximum likelihood — codml","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"Fits COD GMRF model using maximum likelihood. Additional arguments passed `optim`. tau provided, `codls` also used optimise parameter. method slower `codls` recommended trees several hundred samples.","code":""},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"","code":"codml(tr1, logtau = NULL, profcontrol = list(), ...)"},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"tr1 Phylogenetic tree ape::phylo format logtau Precision parameter. NULL, invoke `tauprofile` find best value. profcontrol Optional list arguments passed `tauprofile` ... Additional arguments passed `mgcv::gam`","code":""},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"COD GMRF model fit. Includes GAM model fit.","code":""},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"ML COD GMRF method currently support inverse probability weighting samples. Use `codls` sample weighting needed.","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/coef.gpgmrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Capitalized Title (ideally limited to 65 characters) — coef.gpgmrf","text":"","code":"coef.gpgmrf(f)"},{"path":"https://emvolz.github.io/cod/reference/coef.gpgmrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Capitalized Title (ideally limited to 65 characters) — coef.gpgmrf","text":"f","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/coef.gpgmrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Capitalized Title (ideally limited to 65 characters) — coef.gpgmrf","text":"","code":"##---- Should be DIRECTLY executable !! ---- ##-- ==>  Define data, use random, ##--  or standard data sets, see data().  ## The function is currently defined as function (f)  {     stopifnot(inherits(f, \"gpgmrf\"))     f$coef   } #> function (f)  #> { #>     stopifnot(inherits(f, \"gpgmrf\")) #>     f$coef #> } #> <environment: 0x55d88410cd68>"},{"path":"https://emvolz.github.io/cod/reference/computeclusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","title":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","text":"Compute phylogenetic clusters cutting tree branches large changes coalescent odds","code":""},{"path":"https://emvolz.github.io/cod/reference/computeclusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","text":"","code":"computeclusters(f, clth = NULL, rescale = TRUE, includeinternals = TRUE)"},{"path":"https://emvolz.github.io/cod/reference/computeclusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","text":"f model fit `codls` clth Numeric threshold change coalescent log odds. NULL, guess good threshold based CH index rescale TRUE (default), coalescent log odds rescaled (mean zero, unit variance) prior applying thresholds includeinternals TRUE (default), internal nodes also included cluster output","code":""},{"path":"https://emvolz.github.io/cod/reference/computeclusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","text":"data frame cluster asignment tip","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/fitgpgmrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Capitalized Title (ideally limited to 65 characters) — fitgpgmrf","text":"","code":"fitgpgmrf(tr1, tau = c(1, NULL), profcontrol = list(), inverseprobabilityweights = NULL)"},{"path":"https://emvolz.github.io/cod/reference/fitgpgmrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Capitalized Title (ideally limited to 65 characters) — fitgpgmrf","text":"tr1  tau  profcontrol  inverseprobabilityweights","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/fitgpgmrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Capitalized Title (ideally limited to 65 characters) — fitgpgmrf","text":"","code":"##---- Should be DIRECTLY executable !! ---- ##-- ==>  Define data, use random, ##--  or standard data sets, see data().  ## The function is currently defined as function (tr1, tau = c(1, NULL), profcontrol = list(), inverseprobabilityweights = NULL)  {     if (!inherits(tr1, \"cggephylo\") & inherits(tr1, \"phylo\")) {         tr1 <- .maketreedata(tr1)     }     tau = tau[1]     tpdf <- NULL     if (is.null(tau)) {         tpargs <- modifyList(TPARGS, profcontrol)         tpargs$tr = tr1         tpargs$ipw = inverseprobabilityweights         tpdf <- do.call(tauprofile, tpargs)         tau <- tpdf$tau[which.min(tpdf$loss)]         print(tpdf)     }     st1 <- Sys.time()     whno = tr1$whno     nr = tr1$nr     i <- which(!is.na(tr1$parent))     ary = rep(0, nr)     y = c(ary, tr1$nodey)     arw = tau/tr1$brlens     nodew <- .computenodew(tr1, inverseprobabilityweights)     w = c(arw, nodew)     st2b <- Sys.time()     ai = 1:nr     aj = whno     ax = rep(1, nr)     ai = c(ai, 1:nr)     aj = c(aj, tr1$parent[whno])     ax = c(ax, rep(-1, nr))     k <- nr + 1     coindices <- list()     coii <- 1     for (co in tr1$coalescentcohorts) {         coindices[[coii]] <- k:(k + length(co) - 1)         coii <- coii + 1         k <- k + length(co)     }     ncoi <- sum(sapply(tr1$coalescentcohorts, length))     coi <- (nr + 1):(nr + ncoi)     coj <- do.call(c, tr1$coalescentcohorts)     cox <- rep(1, ncoi)     ai <- c(ai, coi)     aj <- c(aj, coj)     ax <- c(ax, cox)     X <- Matrix::sparseMatrix(i = ai, j = aj, x = ax)     W <- Matrix::Diagonal(x = w)     QQ <- t(X) %*% W %*% X     b <- t(X) %*% W %*% y     f2beta = as.vector(solve(QQ, b))     st3 <- Sys.time()     structure(list(coef = f2beta, tau = tau, data = tr1, X = X,          W = W, y = y, nr = nr, arindices = 1:nr, logoddsindices = (nr +              1):nrow(X), istartnodeterms = nr + 1, coindices = coindices,          tauprofile = tpdf, runtime = st3 - st1), class = \"gpgmrf\")   } #> function (tr1, tau = c(1, NULL), profcontrol = list(), inverseprobabilityweights = NULL)  #> { #>     if (!inherits(tr1, \"cggephylo\") & inherits(tr1, \"phylo\")) { #>         tr1 <- .maketreedata(tr1) #>     } #>     tau = tau[1] #>     tpdf <- NULL #>     if (is.null(tau)) { #>         tpargs <- modifyList(TPARGS, profcontrol) #>         tpargs$tr = tr1 #>         tpargs$ipw = inverseprobabilityweights #>         tpdf <- do.call(tauprofile, tpargs) #>         tau <- tpdf$tau[which.min(tpdf$loss)] #>         print(tpdf) #>     } #>     st1 <- Sys.time() #>     whno = tr1$whno #>     nr = tr1$nr #>     i <- which(!is.na(tr1$parent)) #>     ary = rep(0, nr) #>     y = c(ary, tr1$nodey) #>     arw = tau/tr1$brlens #>     nodew <- .computenodew(tr1, inverseprobabilityweights) #>     w = c(arw, nodew) #>     st2b <- Sys.time() #>     ai = 1:nr #>     aj = whno #>     ax = rep(1, nr) #>     ai = c(ai, 1:nr) #>     aj = c(aj, tr1$parent[whno]) #>     ax = c(ax, rep(-1, nr)) #>     k <- nr + 1 #>     coindices <- list() #>     coii <- 1 #>     for (co in tr1$coalescentcohorts) { #>         coindices[[coii]] <- k:(k + length(co) - 1) #>         coii <- coii + 1 #>         k <- k + length(co) #>     } #>     ncoi <- sum(sapply(tr1$coalescentcohorts, length)) #>     coi <- (nr + 1):(nr + ncoi) #>     coj <- do.call(c, tr1$coalescentcohorts) #>     cox <- rep(1, ncoi) #>     ai <- c(ai, coi) #>     aj <- c(aj, coj) #>     ax <- c(ax, cox) #>     X <- Matrix::sparseMatrix(i = ai, j = aj, x = ax) #>     W <- Matrix::Diagonal(x = w) #>     QQ <- t(X) %*% W %*% X #>     b <- t(X) %*% W %*% y #>     f2beta = as.vector(solve(QQ, b)) #>     st3 <- Sys.time() #>     structure(list(coef = f2beta, tau = tau, data = tr1, X = X,  #>         W = W, y = y, nr = nr, arindices = 1:nr, logoddsindices = (nr +  #>             1):nrow(X), istartnodeterms = nr + 1, coindices = coindices,  #>         tauprofile = tpdf, runtime = st3 - st1), class = \"gpgmrf\") #> } #> <environment: 0x55d8807046c8>"},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the local branching index (LBI) — lbi","title":"Compute the local branching index (LBI) — lbi","text":"Compute local branching index (LBI)","code":""},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the local branching index (LBI) — lbi","text":"","code":"lbi(tr, logtau)"},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the local branching index (LBI) — lbi","text":"tr ape::phylo logtau Smoothing parameter","code":""},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the local branching index (LBI) — lbi","text":"Vector local branching index values every node input tree","code":""},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute the local branching index (LBI) — lbi","text":"Neher, Richard ., Colin . Russell, Boris . Shraiman. Elife 3 (2014): e03568.","code":""},{"path":"https://emvolz.github.io/cod/reference/neffextant.html","id":null,"dir":"Reference","previous_headings":"","what":"Effective number of extant lineages — neffextant","title":"Effective number of extant lineages — neffextant","text":"Effective number extant lineages","code":""},{"path":"https://emvolz.github.io/cod/reference/neffextant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effective number of extant lineages — neffextant","text":"","code":"neffextant(f)"},{"path":"https://emvolz.github.io/cod/reference/neffextant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Effective number of extant lineages — neffextant","text":"f Fit `codls`","code":""},{"path":"https://emvolz.github.io/cod/reference/neffextant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Effective number of extant lineages — neffextant","text":"Numeric effective number extant lineages","code":""},{"path":"https://emvolz.github.io/cod/reference/optcodsmooth.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — optcodsmooth","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — optcodsmooth","text":"Evaluate loss function cod model across range tau (precision parameter) values","code":""},{"path":"https://emvolz.github.io/cod/reference/optcodsmooth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — optcodsmooth","text":"","code":"optcodsmooth(   tr,   logtaulb = -4,   logtauub = 35,   res = 5,   startpc = 75,   endpc = 100,   nobj = 100,   ipw = NULL,   ncpu = 1,   tol = 0.001 )"},{"path":"https://emvolz.github.io/cod/reference/optcodsmooth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — optcodsmooth","text":"tr phylogenetic tree ape::phylo format logtaulb Lower bound precision parameteters logtauub Upper bound precision parameteters res Number tau values evaluate startpc initial per cent nodes tree counting root tips loss function evaluated endpc final per cent nodes tree counting root tips loss function evaluated nobj integer number points along tree loss function evaluated. Inf, use points startpc endpc, may slow. ipw Optional inverse probability weights sample","code":""},{"path":"https://emvolz.github.io/cod/reference/optcodsmooth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — optcodsmooth","text":"data frame containing loss function evaluated range tau values","code":""},{"path":"https://emvolz.github.io/cod/reference/optsmooth.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","title":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","text":"function maximises deviance explained future evolution given branch statistic via dependence smoothing parameter (tau). function must given tree function (e.g. `codls` `lbi`) takes tree smoothing parameter returns given branch statistic. association branch statistic future coalescent events (prediction evolution) modelled using GAM adjusting branch lengths distance root.","code":""},{"path":"https://emvolz.github.io/cod/reference/optsmooth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","text":"","code":"optsmooth(   tr,   func,   logtaulb = -4,   logtauub = 35,   startpc = 50,   endpc = 100,   nobj = 100 )"},{"path":"https://emvolz.github.io/cod/reference/optsmooth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","text":"tr phylogenetic tree ape::phylo format logtaulb Lower bound precision parameteters logtauub Upper bound precision parameteters startpc initial per cent nodes tree counting root tips loss function evaluated endpc final per cent nodes tree counting root tips loss function evaluated nobj integer number points along tree loss function evaluated. Inf, use points startpc endpc, may slow.","code":""},{"path":"https://emvolz.github.io/cod/reference/optsmooth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","text":"Output `optimise`. $minimum contains optimal smoothing parameter","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/plot.gpgmrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Capitalized Title (ideally limited to 65 characters) — plot.gpgmrf","text":"","code":"plot.gpgmrf(f)"},{"path":"https://emvolz.github.io/cod/reference/plot.gpgmrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Capitalized Title (ideally limited to 65 characters) — plot.gpgmrf","text":"f","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/plot.gpgmrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Capitalized Title (ideally limited to 65 characters) — plot.gpgmrf","text":"","code":"##---- Should be DIRECTLY executable !! ---- ##-- ==>  Define data, use random, ##--  or standard data sets, see data().  ## The function is currently defined as function (f)  {     stopifnot(inherits(f, \"gpgmrf\"))     f2beta = f$coef     tr1 = f$data     class(tr1) <- \"phylo\"     fdf <- data.frame(node = 1:length(tr1$nodetimes), theta = f2beta)     gtr1 = ggtree::ggtree(tr1) %<+% fdf     gtr1 + aes(color = theta) + scale_color_gradient2(low = \"blue\",          mid = \"lightblue\", high = \"red\", midpoint = 0, limits = range(fdf$theta),          name = \"ψ\") + ggtree::theme_tree2() + ggtree::geom_tiplab()   } #> function (f)  #> { #>     stopifnot(inherits(f, \"gpgmrf\")) #>     f2beta = f$coef #>     tr1 = f$data #>     class(tr1) <- \"phylo\" #>     fdf <- data.frame(node = 1:length(tr1$nodetimes), theta = f2beta) #>     gtr1 = ggtree::ggtree(tr1) %<+% fdf #>     gtr1 + aes(color = theta) + scale_color_gradient2(low = \"blue\",  #>         mid = \"lightblue\", high = \"red\", midpoint = 0, limits = range(fdf$theta),  #>         name = \"ψ\") + ggtree::theme_tree2() + ggtree::geom_tiplab() #> } #> <environment: 0x55d880f922e8>"},{"path":"https://emvolz.github.io/cod/reference/plotclusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a fit from `codls` and cluster assigment from `computeclusters` — plotclusters","title":"Plots a fit from `codls` and cluster assigment from `computeclusters` — plotclusters","text":"Plots fit `codls` cluster assigment `computeclusters`","code":""},{"path":"https://emvolz.github.io/cod/reference/plotclusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a fit from `codls` and cluster assigment from `computeclusters` — plotclusters","text":"","code":"plotclusters(f, clusterdf, ...)"},{"path":"https://emvolz.github.io/cod/reference/plotclusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a fit from `codls` and cluster assigment from `computeclusters` — plotclusters","text":"`codls` fit Output data frame `computeclusters`","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/print.gpgmrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Capitalized Title (ideally limited to 65 characters) — print.gpgmrf","text":"","code":"print.gpgmrf(f)"},{"path":"https://emvolz.github.io/cod/reference/print.gpgmrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Capitalized Title (ideally limited to 65 characters) — print.gpgmrf","text":"f","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/print.gpgmrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Capitalized Title (ideally limited to 65 characters) — print.gpgmrf","text":"","code":"##---- Should be DIRECTLY executable !! ---- ##-- ==>  Define data, use random, ##--  or standard data sets, see data().  ## The function is currently defined as function (f)  {     stopifnot(inherits(f, \"gpgmrf\"))     cat(\" Genealogical placement GMRF model fit \\n\")     print(f$data)     cat(\"Range of coefficients: \\n\")     print(range(coef(f)))     cat(glue::glue(\"Precision parameter (tau): {f$tau} \\n\"))     cat(\"\\n\")     invisible(f)   } #> function (f)  #> { #>     stopifnot(inherits(f, \"gpgmrf\")) #>     cat(\" Genealogical placement GMRF model fit \\n\") #>     print(f$data) #>     cat(\"Range of coefficients: \\n\") #>     print(range(coef(f))) #>     cat(glue::glue(\"Precision parameter (tau): {f$tau} \\n\")) #>     cat(\"\\n\") #>     invisible(f) #> } #> <environment: 0x55d87ccefd70>"},{"path":"https://emvolz.github.io/cod/reference/rmsclo.html","id":null,"dir":"Reference","previous_headings":"","what":"Root mean square coalescent log odds — rmsclo","title":"Root mean square coalescent log odds — rmsclo","text":"summary statistic describes amount variation coalescent rates across lineages phylogenetic tree defined $$ \\sqrt{ \\sum_i l_i \\psi_i^2 / L }  $$ sum branches tree weighted branch length \\(l_i\\)  \\( L = \\sum_i l_i  \\)","code":""},{"path":"https://emvolz.github.io/cod/reference/rmsclo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Root mean square coalescent log odds — rmsclo","text":"","code":"rmsclo(f)"},{"path":"https://emvolz.github.io/cod/reference/rmsclo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Root mean square coalescent log odds — rmsclo","text":"f Fit `codls`","code":""},{"path":"https://emvolz.github.io/cod/reference/rmsclo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Root mean square coalescent log odds — rmsclo","text":"Numeric RMSCLO","code":""},{"path":"https://emvolz.github.io/cod/reference/tauprofile.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","text":"Evaluate loss function cod model across range tau (precision parameter) values","code":""},{"path":"https://emvolz.github.io/cod/reference/tauprofile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","text":"","code":"tauprofile(   tr,   logtaulb = -4,   logtauub = 35,   res = 11,   startpc = 75,   endpc = 100,   nobj = 100,   ipw = NULL,   ncpu = 1 )"},{"path":"https://emvolz.github.io/cod/reference/tauprofile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","text":"tr phylogenetic tree ape::phylo format logtaulb Lower bound precision parameteters logtauub Upper bound precision parameteters res Number tau values evaluate startpc initial per cent nodes tree counting root tips loss function evaluated endpc final per cent nodes tree counting root tips loss function evaluated nobj integer number points along tree loss function evaluated. Inf, use points startpc endpc, may slow. ipw Optional inverse probability weights sample","code":""},{"path":"https://emvolz.github.io/cod/reference/tauprofile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","text":"data frame containing loss function evaluated range tau values","code":""}]
