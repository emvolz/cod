[{"path":"https://emvolz.github.io/cod/articles/ngono.html","id":"estimating-coalescent-odds","dir":"Articles","previous_headings":"","what":"Estimating coalescent odds","title":"N. gonorrhea: Computing coalescent odds, identifying growing lineages, cluster identification & sample reweighting","text":"main function estimate coalescent odds using weighted least squares codls: required argument time-scaled phylogenetic tree. method models correlation coalescent odds phylogenetic lineages using Gaussian-Markov Random Field includes precision parameter logtau. indepently estimated, can provided codls speed estimation, omitted, logtau automatically estimated using tauprofile function. can also speed codls using multiple CPUs ncpu argument. Plotting fit display tree estimated log odds coalescence mapped colour branches. Note requires ggtree package installed.  coalescent odds branch can retrieved using coef, e.g.: order nodes input tree. Let’s merge estimated coalescent odds back metadata subsequent analysis:","code":"f <- codls( tr ) ##    logtau      loss optimal ## 1    -4.0 200516.48         ## 2     0.1  87477.40         ## 3     4.2  86547.03     *** ## 4     8.3  86589.56         ## 5    12.4       Inf         ## 6    16.5       Inf         ## 7    20.6       Inf         ## 8    24.7       Inf         ## 9    28.8       Inf         ## 10   32.9       Inf         ## 11   37.0       Inf f ##  Genealogical placement GMRF model fit  ##  ## Phylogenetic tree with 1102 tips and 1101 internal nodes. ##  ## Tip labels: ##   17176_1#21, 15335_3#33, 15335_6#51, 15335_4#63, 15335_5#50, 8727_8#36, ... ##  ## Rooted; includes branch length(s). ## Range of coefficients:  ## -0.442259845161674 0.426205484263409 ## Precision parameter (log tau): 4.2 # Plot the tree with coalescent odds - handle potential ggtree issues tryCatch({   plot(f) }, error = function(e) {   cat(\"Plot generation failed due to ggtree compatibility issue:\\n\")   cat(e$message, \"\\n\")   cat(\"Tree summary:\\n\")   print(f)   cat(\"\\nCoalescent odds summary:\\n\")   print(summary(coef(f))) }) coef(f)[1:4] ## [1] 0.003407523 0.005130719 0.005719041 0.006293182 fdf <- data.frame( tip = f$data$tip.label, psi = coef(f)[1:Ntip(tr)] ) md$tip  <- md$ID  md <- merge( md, fdf, by = 'tip') head( md ) ##          tip         ID PEN TET SPC CFX CRO CIP AZI Clinic Year         psi ## 1  15335_2#1  15335_2#1   2   2   0   2   0   2   1    POR 2012 -0.04803569 ## 2 15335_2#10 15335_2#10   1   1   0   0   0   0   2    MIN 2005  0.24893462 ## 3 15335_2#11 15335_2#11   1   1   0   0   0   0   2    MIN 2005  0.24848434 ## 4 15335_2#12 15335_2#12   1   2   0   0   0   0   2    LVG 2006  0.24821303 ## 5 15335_2#13 15335_2#13   2   2   0  NA   0   2   2    CHI 2008 -0.02901797 ## 6 15335_2#14 15335_2#14   2   2   0  NA   0   0   2    KCY 2008 -0.04413655"},{"path":"https://emvolz.github.io/cod/articles/ngono.html","id":"sample-weights","dir":"Articles","previous_headings":"","what":"Sample weights","title":"N. gonorrhea: Computing coalescent odds, identifying growing lineages, cluster identification & sample reweighting","text":"examine relationship coalescent odds samples originated (Clinic) clinics significantly higher values: possible occurred locations sampled intensively clinics can artificially increase coalescent rates higher local density co-circulating lineages. Samples can -weighted codls passing *weights* argument, ameliorate bias -sampling know much -sampling took place. Unfortunately, rarely known, cod includes routine consider range sample weights identify maximum weight longer significant relationship coalescent odds given variable (usually geographic). identify samples “MIA” clinical pass autoreweight function. Note cases, association disappear even weight zero lineages surrounding given samples also higher coalescent odds. cases, relationship likely authentic. exactly see . Even weighting samples 1% (unrealistically low) remains significant association coalescent odds. Consequently, fit identical original fit.","code":"table( md$Clinic ) |> sort() ##  ## COL LA2 SLC STL FBG GRB IND PON NOR LBC NYC CLE RIC KCY ALB DTR OKC DAL CIN ATL  ##   3   3   3   3   4   6   6   6   7   8   8  11  11  13  14  14  14  16  22  25  ## BHM MIA SEA DEN BAL HON POR MIN LAX ORA PHX SFO PHI CHI LVG SDG  ##  28  28  29  30  33  35  48  51  53  62  64  67  69  71  85 152 s <- lm( psi ~ Clinic, data = md) |> summary()  s ##  ## Call: ## lm(formula = psi ~ Clinic, data = md) ##  ## Residuals: ##      Min       1Q   Median       3Q      Max  ## -0.50273 -0.08555 -0.03763  0.02845  0.56277  ##  ## Coefficients: ##               Estimate Std. Error t value Pr(>|t|)   ## (Intercept)  0.0052379  0.0480984   0.109   0.9133   ## ClinicATL    0.0037715  0.0600749   0.063   0.9500   ## ClinicBAL   -0.0297057  0.0574015  -0.518   0.6049   ## ClinicBHM   -0.0842535  0.0589083  -1.430   0.1529   ## ClinicCHI    0.0139142  0.0526273   0.264   0.7915   ## ClinicCIN   -0.0352066  0.0615277  -0.572   0.5673   ## ClinicCLE   -0.1300334  0.0725111  -1.793   0.0732 . ## ClinicCOL   -0.1405248  0.1144972  -1.227   0.2200   ## ClinicDAL    0.0690866  0.0658615   1.049   0.2944   ## ClinicDEN    0.0412778  0.0582501   0.709   0.4787   ## ClinicDTR   -0.0856221  0.0680215  -1.259   0.2084   ## ClinicFBG   -0.1115689  0.1020322  -1.093   0.2744   ## ClinicGRB    0.1535391  0.0878153   1.748   0.0807 . ## ClinicHON   -0.0043148  0.0569108  -0.076   0.9396   ## ClinicIND   -0.0488006  0.0878153  -0.556   0.5785   ## ClinicKCY    0.0552351  0.0693172   0.797   0.4257   ## ClinicLA2    0.1110863  0.1144972   0.970   0.3322   ## ClinicLAX    0.0161195  0.0540792   0.298   0.7657   ## ClinicLBC   -0.0761099  0.0797622  -0.954   0.3402   ## ClinicLVG   -0.0550232  0.0519086  -1.060   0.2894   ## ClinicMIA    0.0763673  0.0589083   1.296   0.1951   ## ClinicMIN   -0.0261175  0.0543003  -0.481   0.6306   ## ClinicNOR   -0.1240360  0.0833089  -1.489   0.1368   ## ClinicNYC   -0.0308319  0.0797622  -0.387   0.6992   ## ClinicOKC   -0.1496981  0.0680215  -2.201   0.0280 * ## ClinicORA    0.0320981  0.0532527   0.603   0.5468   ## ClinicPHI   -0.0270736  0.0527528  -0.513   0.6079   ## ClinicPHX    0.0520299  0.0530992   0.980   0.3274   ## ClinicPON   -0.0770099  0.0878153  -0.877   0.3807   ## ClinicPOR    0.0006079  0.0546646   0.011   0.9911   ## ClinicRIC   -0.0593261  0.0725111  -0.818   0.4134   ## ClinicSDG    0.0291153  0.0502647   0.579   0.5625   ## ClinicSEA   -0.0522784  0.0585688  -0.893   0.3723   ## ClinicSFO   -0.0039325  0.0528854  -0.074   0.9407   ## ClinicSLC   -0.2952074  0.1144972  -2.578   0.0101 * ## ClinicSTL   -0.2333512  0.1144972  -2.038   0.0418 * ## --- ## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 ##  ## Residual standard error: 0.18 on 1066 degrees of freedom ## Multiple R-squared:  0.07834,    Adjusted R-squared:  0.04808  ## F-statistic: 2.589 on 35 and 1066 DF,  p-value: 1.699e-06 # Clinics associated with psi : signifclinics <- rownames(s$coefficients)[ s$coefficients[ , 4]  < .1 ] signifclinics <- substr(signifclinics, 7,9 ) # Subset of tips from clinics associated with psi : reweighttips  <- md$tip[ md$Clinic %in% signifclinics ] arw <- autoreweight( f, reweighttips, wlb = 1e-2, wub = .5, res = 5, alpha = .02 ) f = arw$fit arw$summary ##   sampleweight            p ## 1       0.0100 1.554659e-05 ## 2       0.1325 2.257137e-05 ## 3       0.2550 3.269453e-05 ## 4       0.3775 4.723516e-05 ## 5       0.5000 6.804639e-05"},{"path":"https://emvolz.github.io/cod/articles/ngono.html","id":"antibiotic-resistance","dir":"Articles","previous_headings":"","what":"Antibiotic resistance","title":"N. gonorrhea: Computing coalescent odds, identifying growing lineages, cluster identification & sample reweighting","text":"examine relationship coalescent odds antibiotic resistance. First, replot coloured tree alongside resistance phenotypes. looks like higher coalescent odds associated AZI resistance abx shows positive effect. Let’s quantify . linear regression coalescent odds abx time, infer mean psi end sampling (year 2013). result plotted:  fact, resistance AZI expanded rapidly data collected, prevalence 0.6% 2013 4.5% 20173. rapid growth among antibiotics.","code":"abxs <- c( 'PEN', 'TET', 'CFX', 'CRO', 'CIP', 'AZI') abxmat <- as.matrix(md[, abxs ] ) abxmat <- apply( abxmat, 2, function(x) (x == \"2\") ) # The value of '2' is coded as abx resistant rownames( abxmat ) <- md$tip  head(abxmat) ##              PEN   TET   CFX   CRO   CIP   AZI ## 15335_2#1   TRUE  TRUE  TRUE FALSE  TRUE FALSE ## 15335_2#10 FALSE FALSE FALSE FALSE FALSE  TRUE ## 15335_2#11 FALSE FALSE FALSE FALSE FALSE  TRUE ## 15335_2#12 FALSE  TRUE FALSE FALSE FALSE  TRUE ## 15335_2#13  TRUE  TRUE    NA FALSE  TRUE  TRUE ## 15335_2#14  TRUE  TRUE    NA FALSE FALSE  TRUE abxmat[ is.na(abxmat) ] <- FALSE  # Try to create tree plot with heatmap, handle ggtree issues tryCatch({   trpl <- plot(f) +      ggplot2::scale_color_gradient2( low='blue'                                   , mid = 'lightblue'                                   , high = 'red'                                   , midpoint = 0                                   , limits = range(fdf$psi)                                   , name = \"ψ\" )   trpl <- ggtree::gheatmap( trpl, abxmat, colnames_position='top', colnames_offset_y = -11)   trpl$data$label = '' # suppress tip labels    print(trpl) }, error = function(e) {   cat(\"Tree plot with heatmap failed due to ggtree compatibility issue:\\n\")   cat(e$message, \"\\n\")   cat(\"\\nAntibiotic resistance summary:\\n\")   print(colSums(abxmat))   cat(\"\\nSamples with highest coalescent odds:\\n\")   top_psi <- head(md[order(md$psi, decreasing=TRUE), c(\"tip\", \"psi\", abxs)], 10)   print(top_psi) }) ## Tree plot with heatmap failed due to ggtree compatibility issue: ## <ggtree> object properties are invalid: ## - @mapping must be <ggplot2::mapping>, not S3<data.frame>  ##  ## Antibiotic resistance summary: ## PEN TET CFX CRO CIP AZI  ## 537 661 266   8 594 232  ##  ## Samples with highest coalescent odds: ##            tip       psi PEN TET CFX CRO CIP AZI ## 492 15335_7#38 0.4262055   1   2   0   0   0   2 ## 512 15335_7#57 0.4262055   1   2   0   0   0   2 ## 490 15335_7#36 0.4262054   1   2   0   0   0   2 ## 482 15335_7#29 0.4259646   1   2   0   0   0   2 ## 488 15335_7#34 0.4259645   1   2   0   0   0   2 ## 479 15335_7#26 0.4257999   1   2   0   0   0   2 ## 459 15335_6#93 0.4254206   1   0   0   0   0   1 ## 700 17176_1#28 0.4254206   1   0   0   0   0   1 ## 702  17176_1#3 0.4253203   1   0   0   0   0   1 ## 698 17176_1#26 0.4251364   1   0   0   0   0   1 md$t  <- md$Year - min(md$Year) psi2013 <- sapply( abxs, function(x) {     md1 <- md     md1$v <- md1[[x]] == 2     m = lm( psi ~ v*t  , data = md1 )     predict( m, newdata= data.frame( psi = NA, v = TRUE, t = 13 ) , interval='confidence') }) |> setNames( abxs ) ebdf <- as.data.frame( t( psi2013 ) )  colnames(ebdf) <- c( 'Median', '2.5%', '97.5%' ) ebdf$abx = rownames( ebdf )  ebdf <- ebdf[ order( ebdf$Median ) , ]  print( ebdf ) ##           Median        2.5%       97.5% abx ## CRO -0.062852959 -0.28257319  0.15686727 CRO ## PEN -0.042395359 -0.06566536 -0.01912536 PEN ## CIP -0.041630966 -0.06456462 -0.01869732 CIP ## CFX -0.005595061 -0.04700795  0.03581783 CFX ## TET -0.003377564 -0.02501186  0.01825674 TET ## AZI  0.247253178  0.21017410  0.28433226 AZI peb = ggplot2::ggplot(ebdf, ggplot2::aes(x = abx, y = Median, ymin = `2.5%`, ymax = `97.5%`) ) + ggplot2::geom_errorbar(width=0) +  ggplot2::geom_point() +  ggplot2::labs(y = 'psi', x = '' ) peb"},{"path":"https://emvolz.github.io/cod/articles/ngono.html","id":"phylogenetic-clusters","dir":"Articles","previous_headings":"","what":"Phylogenetic clusters","title":"N. gonorrhea: Computing coalescent odds, identifying growing lineages, cluster identification & sample reweighting","text":"alternative way look coalescent odds terms phylogenetic clusters. clades defined threshold change coalescent odds along lineage, low high values. subjectivity choice clustering thresholds best choice depends application, however cod provides method based Calinski-Harabasz index. , compute clusters using maximum CH index. Note threshold provided, computeclusters automatically select optimal threshold: Plotting shows one cluster closely matches clade high levels AZI resistance high coalescent odds, alternative way analyse data identify clusters high coalescent odds characterise resistance patters within clusters. clusters can visualised running plotclusters(f, chdf).","code":"chis <- chindices(f, clths = seq( .03, .4, length = 20 ), rescale=TRUE) chis ##     threshold        CH optimal ## 1  0.03000000 1502518.1         ## 2  0.04947368  650599.0         ## 3  0.06894737  807982.9         ## 4  0.08842105  902511.2         ## 5  0.10789474  946716.4         ## 6  0.12736842 1334924.7         ## 7  0.14684211 1532793.1         ## 8  0.16631579 1641530.8     *** ## 9  0.18578947  786818.6         ## 10 0.20526316  950306.2         ## 11 0.22473684  885988.9         ## 12 0.24421053  885988.9         ## 13 0.26368421 1215831.1         ## 14 0.28315789 1215831.1         ## 15 0.30263158 1215831.1         ## 16 0.32210526 1215831.1         ## 17 0.34157895 1215831.1         ## 18 0.36105263 1215831.1         ## 19 0.38052632 1215831.1         ## 20 0.40000000 1215831.1 # Using optimal threshold from CH index chdf = computeclusters(f, chis$threshold[which.max(chis$CH)] ) # Alternatively, let computeclusters automatically select optimal threshold: # chdf = computeclusters(f)   head(chdf) ##   node  tip.label clusterid        psi   tip ## 1 1088 15335_5#48         1 -0.4209262  TRUE ## 2 1089 15335_3#80         1 -0.4311232  TRUE ## 3 1089 15335_3#80         1 -0.4311232  TRUE ## 4 2191                    1 -0.3838401 FALSE ## 5 1065 17176_1#39         2 -0.4356554  TRUE ## 6 1066  8289_2#72         2 -0.4411569  TRUE # Cluster summary statistics cat(\"Cluster summary:\\n\") ## Cluster summary: print(table(chdf$clusterid)) ##  ##   1   2   3   4   5   6   7   8   9  10  11  12  13  14  ##   4  46 158 270 104  88 888 910 145   3  15 457   1  51 cat(\"\\nCluster statistics (coalescent odds by cluster):\\n\") ##  ## Cluster statistics (coalescent odds by cluster): cluster_stats <- aggregate(chdf$psi, by=list(chdf$clusterid),                            function(x) c(mean=mean(x, na.rm=TRUE),                                        sd=sd(x, na.rm=TRUE),                                        n=length(x))) names(cluster_stats) <- c(\"cluster\", \"psi_stats\") print(cluster_stats) ##    cluster psi_stats.mean  psi_stats.sd   psi_stats.n ## 1        1   -0.416753158   0.022462421   4.000000000 ## 2        2   -0.416514088   0.019188764  46.000000000 ## 3        3   -0.239161430   0.039221155 158.000000000 ## 4        4   -0.071805631   0.012269594 270.000000000 ## 5        5   -0.017465734   0.018791471 104.000000000 ## 6        6   -0.013355858   0.010180204  88.000000000 ## 7        7    0.315540443   0.091935636 888.000000000 ## 8        8   -0.032857085   0.016487044 910.000000000 ## 9        9   -0.094540079   0.021518781 145.000000000 ## 10      10   -0.154503030   0.018780184   3.000000000 ## 11      11   -0.216450242   0.009101256  15.000000000 ## 12      12   -0.076401526   0.064003733 457.000000000 ## 13      13   -0.277591516            NA   1.000000000 ## 14      14   -0.297566015   0.018720376  51.000000000"},{"path":[]},{"path":"https://emvolz.github.io/cod/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Erik Volz. Maintainer.","code":""},{"path":"https://emvolz.github.io/cod/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Volz E (2025). cod: Inference Coalescent ODds Phylogenetic Trees. R package version 0.7.0, https://emvolz.github.io/cod/.","code":"@Manual{,   title = {cod: Inference of Coalescent ODds in Phylogenetic Trees},   author = {Erik Volz},   year = {2025},   note = {R package version 0.7.0},   url = {https://emvolz.github.io/cod/}, }"},{"path":[]},{"path":"https://emvolz.github.io/cod/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"cod R package provides tools inferring variation coalescent rates across branches phylogenetic trees. provides methods identify growing lineages, adjust biased sampling, compute phylogenetic clusters, optimize cluster thresholds, summarize rate variations.","code":""},{"path":"https://emvolz.github.io/cod/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"can install cod GitHub using devtools:","code":"# install.packages(\"devtools\") devtools::install_github(\"erikvolz/cod\")"},{"path":"https://emvolz.github.io/cod/index.html","id":"dependencies","dir":"","previous_headings":"","what":"Dependencies","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"package requires several dependencies: - Matrix (>= 1.7) - ape (>= 5.0) - glue (>= 1.0.0) - mgcv (>= 1.9-1) - parallel Optional packages visualization: - ggtree (>= 3.12.0) - ggplot2 (>= 3.0.0)","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/index.html","id":"estimating-coalescent-odds","dir":"","previous_headings":"Key Features","what":"Estimating Coalescent Odds","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"main function codls() estimates coalescent odds using weighted least squares:","code":"# Load a phylogenetic tree tr <- ape::read.tree(\"your_tree_file.nwk\")  # Fit the COD GMRF model f <- codls(tr)  # View summary summary(f)  # Plot the results (requires ggtree) plot(f)"},{"path":"https://emvolz.github.io/cod/index.html","id":"phylogenetic-clustering","dir":"","previous_headings":"Key Features","what":"Phylogenetic Clustering","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"Identify clusters phylogenetic trees based coalescent odds:","code":"# Find optimal clustering threshold chis <- chindices(f, clths = seq(0.1, 1.5, length = 20))  # Compute clusters clusterdf <- computeclusters(f, clth = chis$threshold[which.max(chis$CH)])  # Plot clusters (requires ggtree) plotclusters(f, clusterdf)"},{"path":"https://emvolz.github.io/cod/index.html","id":"adjusting-for-sampling-bias","dir":"","previous_headings":"Key Features","what":"Adjusting for Sampling Bias","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"Correct biased sampling using sample reweighting method:","code":"# Identify tips to reweight reweight_tips <- c(\"tip1\", \"tip2\", \"tip3\")  # Automatically determine optimal reweighting reweightedfit <- autoreweight(f, reweight_tips)"},{"path":"https://emvolz.github.io/cod/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"detailed documentation functions parameters, use R help system vignettes:","code":"?codls ?computeclusters ?autoreweight"},{"path":"https://emvolz.github.io/cod/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"manuscript describing methods package currently preparation.","code":""},{"path":"https://emvolz.github.io/cod/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Inference of Coalescent ODds in Phylogenetic Trees","text":"package available MIT License. See LICENSE file information.","code":""},{"path":"https://emvolz.github.io/cod/reference/autoreweight.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatically reweight sample units that may be oversampled — autoreweight","title":"Automatically reweight sample units that may be oversampled — autoreweight","text":"Given fit `codls` set samples suspected -sampling, function re-compute `codls` range reweighted samples. identify sample weight association lost coalescent odds (psi) given set samples. appropriate weight use association coalescent odds psi due sampling effects due evolutionary effects, note method may mask evolutionary effects present.","code":""},{"path":"https://emvolz.github.io/cod/reference/autoreweight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatically reweight sample units that may be oversampled — autoreweight","text":"","code":"autoreweight(f, rwtips, wlb = 0.01, wub = 0.5, res = 10, alpha = 0.05)"},{"path":"https://emvolz.github.io/cod/reference/autoreweight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Automatically reweight sample units that may be oversampled — autoreweight","text":"f `codls` fit rwtips Vector samples (type character) suspected -sampling wlb Numeric lower bound sample weights examine wub Numeric upper bound sample weights examine res Integer number weights examine alpha p value threshold used selecting optimal weight","code":""},{"path":"https://emvolz.github.io/cod/reference/autoreweight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Automatically reweight sample units that may be oversampled — autoreweight","text":"list components `fit`: reweigthed `codls` fit; `weights`: new vector sample weights; `optimalweight` scalar weight applied oversampled units; `summary`: data frame showing regression p values range weights","code":""},{"path":"https://emvolz.github.io/cod/reference/chindex.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the CH index for selecting clustering thresholds — chindex","title":"Computes the CH index for selecting clustering thresholds — chindex","text":"Computes CH index selecting clustering thresholds","code":""},{"path":"https://emvolz.github.io/cod/reference/chindex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the CH index for selecting clustering thresholds — chindex","text":"","code":"chindex(clusterdf)"},{"path":"https://emvolz.github.io/cod/reference/chindex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the CH index for selecting clustering thresholds — chindex","text":"clusterdf Output `computeclusters`","code":""},{"path":"https://emvolz.github.io/cod/reference/chindices.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute CH index over a range of clustering thresholds — chindices","title":"Compute CH index over a range of clustering thresholds — chindices","text":"Compute CH index range clustering thresholds","code":""},{"path":"https://emvolz.github.io/cod/reference/chindices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute CH index over a range of clustering thresholds — chindices","text":"","code":"chindices(f, clths = seq(0.1, 1.5, length = 20), rescale = TRUE)"},{"path":"https://emvolz.github.io/cod/reference/chindices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute CH index over a range of clustering thresholds — chindices","text":"f fit `codls` clths Numeric vector clustering thresholds rescale Passed `computeclusters`","code":""},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"Fits COD GMRF model using `mgcv::gam` method. Additional arguments can passed `gam`; see documentation method. Using method=\"REML\" can speed execution using constrained maximum likelihood approach. Additionally, approximate reduced-rank MRF model can fitted supplying `k` parameter. tau provided, `codls` also used optimise parameter. method slower `codls` recommended trees several hundred samples.","code":""},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"","code":"codbinomial(tr1, logtau = NULL, k = Inf, profcontrol = list(), ...)"},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"tr1 Phylogenetic tree ape::phylo format logtau Precision parameter. NULL, invoke `tauprofile` find best value. k Fits reduced-rank MRF model k integer < number nodes input tree. can speed calculation reduces precision. profcontrol Optional list arguments passed `tauprofile` ... Additional arguments passed `mgcv::gam`","code":""},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"COD GMRF model fit. Includes GAM model fit.","code":""},{"path":"https://emvolz.github.io/cod/reference/codbinomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a genealogical placement GMRF model using maximum likelihood — codbinomial","text":"ML COD GMRF method currently support inverse probability weighting samples. Use `codls` sample weighting needed.","code":""},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a COD GMRF model using weighted least squares — codls","title":"Fit a COD GMRF model using weighted least squares — codls","text":"Fit COD GMRF model using weighted least squares","code":""},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a COD GMRF model using weighted least squares — codls","text":"","code":"codls(tr1, logtau = NULL, profcontrol = list(), weights = NULL, ncpu = 1)"},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a COD GMRF model using weighted least squares — codls","text":"tr1 Phylogenetic tree ape::phylo format logtau Precision parameter. NULL, invoke `tauprofile` find best value. profcontrol Optional list arguments passed `tauprofile` weights optional vector (named unnamed) sample weights tip input tree ncpu Integer number cpu's use parallel calculation tau profile desired","code":""},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a COD GMRF model using weighted least squares — codls","text":"COD GMRF model fit","code":""},{"path":"https://emvolz.github.io/cod/reference/codls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a COD GMRF model using weighted least squares — codls","text":"","code":"# A simple example that does not have population structure  set.seed( 1111 ) tr <- ape::rtree( 100 ) f <- codls(tr) #>    logtau     loss optimal #> 1    -4.0 839.6102         #> 2     0.1 372.3983         #> 3     4.2 345.3068         #> 4     8.3 345.2809         #> 5    12.4 345.2809         #> 6    16.5 345.2809     *** #> 7    20.6      Inf         #> 8    24.7      Inf         #> 9    28.8      Inf         #> 10   32.9      Inf         #> 11   37.0      Inf         coef(f) |> head()  #> [1] -6.139952e-14 -5.284621e-14 -5.814045e-14 -5.348977e-14 -8.355911e-14 #> [6] -8.360543e-14 summary(f) #>  Genealogical placement GMRF model fit  #>  #> Phylogenetic tree with 100 tips and 99 internal nodes. #>  #> Tip labels: #>   t13, t36, t48, t79, t65, t66, ... #>  #> Rooted; includes branch length(s). #> Range of coefficients:  #> -1.21429158048594e-13 1.49802723784303e-13 #> Precision parameter (log tau): 16.5  #>  #>   logprecision       RMSCLO Neff #> 1         16.5 7.152838e-14  100 #>  if (FALSE) { # \\dontrun{ plot(f) } # }  # This example has population structure  tr0 = rcoal(20); tr0$edge.length <- .01*tr0$edge.length  tr1 = rcoal(80);  dx <- (max(node.depth.edgelength( tr1 ))-max(node.depth.edgelength( tr0 ))) tr0$root.edge <- dx tr <- bind.tree(tr0,tr1, position = dx) f <- codls(tr) #>    logtau     loss optimal #> 1    -4.0 3743.248         #> 2     0.1 3210.785     *** #> 3     4.2 3228.344         #> 4     8.3 3228.611         #> 5    12.4 3228.613         #> 6    16.5      Inf         #> 7    20.6 3228.570         #> 8    24.7 3228.570         #> 9    28.8      Inf         #> 10   32.9      Inf         #> 11   37.0      Inf         summary(f)  #>  Genealogical placement GMRF model fit  #>  #> Phylogenetic tree with 100 tips and 98 internal nodes. #>  #> Tip labels: #>   t18, t1, t16, t9, t7, t11, ... #>  #> Rooted; includes branch length(s). #> Range of coefficients:  #> -0.734776592154461 1.29018258506584 #> Precision parameter (log tau): 0.0999999999999996  #>  #>   logprecision    RMSCLO   Neff #> 1          0.1 0.6358537 91.454 #>  if (FALSE) { # \\dontrun{ plot(f) } # }"},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a genealogical placement GMRF model using maximum likelihood — codml","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"Fits COD GMRF model using maximum likelihood. Additional arguments passed `optim`. tau provided, `codls` also used optimise parameter. method slower `codls` recommended trees several hundred samples.","code":""},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"","code":"codml(tr1, logtau = NULL, profcontrol = list(), ...)"},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"tr1 Phylogenetic tree ape::phylo format logtau Precision parameter. NULL, invoke `tauprofile` find best value. profcontrol Optional list arguments passed `tauprofile` ... Additional arguments passed `mgcv::gam`","code":""},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"COD GMRF model fit. Includes GAM model fit.","code":""},{"path":"https://emvolz.github.io/cod/reference/codml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a genealogical placement GMRF model using maximum likelihood — codml","text":"ML COD GMRF method currently support inverse probability weighting samples. Use `codls` sample weighting needed.","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/coef.gpgmrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Capitalized Title (ideally limited to 65 characters) — coef.gpgmrf","text":"","code":"coef.gpgmrf(f)"},{"path":"https://emvolz.github.io/cod/reference/coef.gpgmrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Capitalized Title (ideally limited to 65 characters) — coef.gpgmrf","text":"f","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/coef.gpgmrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Capitalized Title (ideally limited to 65 characters) — coef.gpgmrf","text":"","code":"##---- Should be DIRECTLY executable !! ---- ##-- ==>  Define data, use random, ##--  or standard data sets, see data().  ## The function is currently defined as function (f)  {     stopifnot(inherits(f, \"gpgmrf\"))     f$coef   } #> function (f)  #> { #>     stopifnot(inherits(f, \"gpgmrf\")) #>     f$coef #> } #> <environment: 0x55de73e3f600>"},{"path":"https://emvolz.github.io/cod/reference/computeclusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","title":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","text":"Compute phylogenetic clusters cutting tree branches large changes coalescent odds","code":""},{"path":"https://emvolz.github.io/cod/reference/computeclusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","text":"","code":"computeclusters(f, clth = NULL, rescale = TRUE, includeinternals = TRUE)"},{"path":"https://emvolz.github.io/cod/reference/computeclusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","text":"f model fit `codls` clth Numeric threshold change coalescent log odds. NULL, guess good threshold based CH index rescale TRUE (default), coalescent log odds rescaled (mean zero, unit variance) prior applying thresholds includeinternals TRUE (default), internal nodes also included cluster output","code":""},{"path":"https://emvolz.github.io/cod/reference/computeclusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute phylogenetic clusters by cutting tree at branches with large changes in coalescent odds — computeclusters","text":"data frame cluster asignment tip","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/fitgpgmrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Capitalized Title (ideally limited to 65 characters) — fitgpgmrf","text":"","code":"fitgpgmrf(tr1, tau = c(1, NULL), profcontrol = list(), inverseprobabilityweights = NULL)"},{"path":"https://emvolz.github.io/cod/reference/fitgpgmrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Capitalized Title (ideally limited to 65 characters) — fitgpgmrf","text":"tr1  tau  profcontrol  inverseprobabilityweights","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/fitgpgmrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Capitalized Title (ideally limited to 65 characters) — fitgpgmrf","text":"","code":"##---- Should be DIRECTLY executable !! ---- ##-- ==>  Define data, use random, ##--  or standard data sets, see data().  ## The function is currently defined as function (tr1, tau = c(1, NULL), profcontrol = list(), inverseprobabilityweights = NULL)  {     if (!inherits(tr1, \"cggephylo\") & inherits(tr1, \"phylo\")) {         tr1 <- .maketreedata(tr1)     }     tau = tau[1]     tpdf <- NULL     if (is.null(tau)) {         tpargs <- modifyList(TPARGS, profcontrol)         tpargs$tr = tr1         tpargs$ipw = inverseprobabilityweights         tpdf <- do.call(tauprofile, tpargs)         tau <- tpdf$tau[which.min(tpdf$loss)]         print(tpdf)     }     st1 <- Sys.time()     whno = tr1$whno     nr = tr1$nr     i <- which(!is.na(tr1$parent))     ary = rep(0, nr)     y = c(ary, tr1$nodey)     arw = tau/tr1$brlens     nodew <- .computenodew(tr1, inverseprobabilityweights)     w = c(arw, nodew)     st2b <- Sys.time()     ai = 1:nr     aj = whno     ax = rep(1, nr)     ai = c(ai, 1:nr)     aj = c(aj, tr1$parent[whno])     ax = c(ax, rep(-1, nr))     k <- nr + 1     coindices <- list()     coii <- 1     for (co in tr1$coalescentcohorts) {         coindices[[coii]] <- k:(k + length(co) - 1)         coii <- coii + 1         k <- k + length(co)     }     ncoi <- sum(sapply(tr1$coalescentcohorts, length))     coi <- (nr + 1):(nr + ncoi)     coj <- do.call(c, tr1$coalescentcohorts)     cox <- rep(1, ncoi)     ai <- c(ai, coi)     aj <- c(aj, coj)     ax <- c(ax, cox)     X <- Matrix::sparseMatrix(i = ai, j = aj, x = ax)     W <- Matrix::Diagonal(x = w)     QQ <- t(X) %*% W %*% X     b <- t(X) %*% W %*% y     f2beta = as.vector(solve(QQ, b))     st3 <- Sys.time()     structure(list(coef = f2beta, tau = tau, data = tr1, X = X,          W = W, y = y, nr = nr, arindices = 1:nr, logoddsindices = (nr +              1):nrow(X), istartnodeterms = nr + 1, coindices = coindices,          tauprofile = tpdf, runtime = st3 - st1), class = \"gpgmrf\")   } #> function (tr1, tau = c(1, NULL), profcontrol = list(), inverseprobabilityweights = NULL)  #> { #>     if (!inherits(tr1, \"cggephylo\") & inherits(tr1, \"phylo\")) { #>         tr1 <- .maketreedata(tr1) #>     } #>     tau = tau[1] #>     tpdf <- NULL #>     if (is.null(tau)) { #>         tpargs <- modifyList(TPARGS, profcontrol) #>         tpargs$tr = tr1 #>         tpargs$ipw = inverseprobabilityweights #>         tpdf <- do.call(tauprofile, tpargs) #>         tau <- tpdf$tau[which.min(tpdf$loss)] #>         print(tpdf) #>     } #>     st1 <- Sys.time() #>     whno = tr1$whno #>     nr = tr1$nr #>     i <- which(!is.na(tr1$parent)) #>     ary = rep(0, nr) #>     y = c(ary, tr1$nodey) #>     arw = tau/tr1$brlens #>     nodew <- .computenodew(tr1, inverseprobabilityweights) #>     w = c(arw, nodew) #>     st2b <- Sys.time() #>     ai = 1:nr #>     aj = whno #>     ax = rep(1, nr) #>     ai = c(ai, 1:nr) #>     aj = c(aj, tr1$parent[whno]) #>     ax = c(ax, rep(-1, nr)) #>     k <- nr + 1 #>     coindices <- list() #>     coii <- 1 #>     for (co in tr1$coalescentcohorts) { #>         coindices[[coii]] <- k:(k + length(co) - 1) #>         coii <- coii + 1 #>         k <- k + length(co) #>     } #>     ncoi <- sum(sapply(tr1$coalescentcohorts, length)) #>     coi <- (nr + 1):(nr + ncoi) #>     coj <- do.call(c, tr1$coalescentcohorts) #>     cox <- rep(1, ncoi) #>     ai <- c(ai, coi) #>     aj <- c(aj, coj) #>     ax <- c(ax, cox) #>     X <- Matrix::sparseMatrix(i = ai, j = aj, x = ax) #>     W <- Matrix::Diagonal(x = w) #>     QQ <- t(X) %*% W %*% X #>     b <- t(X) %*% W %*% y #>     f2beta = as.vector(solve(QQ, b)) #>     st3 <- Sys.time() #>     structure(list(coef = f2beta, tau = tau, data = tr1, X = X,  #>         W = W, y = y, nr = nr, arindices = 1:nr, logoddsindices = (nr +  #>             1):nrow(X), istartnodeterms = nr + 1, coindices = coindices,  #>         tauprofile = tpdf, runtime = st3 - st1), class = \"gpgmrf\") #> } #> <environment: 0x55de7232c480>"},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the local branching index (LBI) — lbi","title":"Compute the local branching index (LBI) — lbi","text":"Compute local branching index (LBI)","code":""},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the local branching index (LBI) — lbi","text":"","code":"lbi(tr, logtau)"},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the local branching index (LBI) — lbi","text":"tr ape::phylo logtau Smoothing parameter","code":""},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the local branching index (LBI) — lbi","text":"Vector local branching index values every node input tree","code":""},{"path":"https://emvolz.github.io/cod/reference/lbi.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute the local branching index (LBI) — lbi","text":"Neher, Richard ., Colin . Russell, Boris . Shraiman. Elife 3 (2014): e03568.","code":""},{"path":"https://emvolz.github.io/cod/reference/neffextant.html","id":null,"dir":"Reference","previous_headings":"","what":"Effective number of extant lineages — neffextant","title":"Effective number of extant lineages — neffextant","text":"Effective number extant lineages","code":""},{"path":"https://emvolz.github.io/cod/reference/neffextant.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Effective number of extant lineages — neffextant","text":"","code":"neffextant(f)"},{"path":"https://emvolz.github.io/cod/reference/neffextant.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Effective number of extant lineages — neffextant","text":"f Fit `codls`","code":""},{"path":"https://emvolz.github.io/cod/reference/neffextant.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Effective number of extant lineages — neffextant","text":"Numeric effective number extant lineages","code":""},{"path":"https://emvolz.github.io/cod/reference/optsmooth.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","title":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","text":"function maximises deviance explained future evolution given branch statistic via dependence smoothing parameter (tau). function must given tree function (e.g. `codls` `lbi`) takes tree smoothing parameter returns given branch statistic. association branch statistic future coalescent events (prediction evolution) modelled using GAM adjusting branch lengths distance root.","code":""},{"path":"https://emvolz.github.io/cod/reference/optsmooth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","text":"","code":"optsmooth(   tr,   func,   logtaulb = -4,   logtauub = 35,   startpc = 50,   endpc = 100,   nobj = 100 )"},{"path":"https://emvolz.github.io/cod/reference/optsmooth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","text":"tr phylogenetic tree ape::phylo format logtaulb Lower bound precision parameteters logtauub Upper bound precision parameteters startpc initial per cent nodes tree counting root tips loss function evaluated endpc final per cent nodes tree counting root tips loss function evaluated nobj integer number points along tree loss function evaluated. Inf, use points startpc endpc, may slow.","code":""},{"path":"https://emvolz.github.io/cod/reference/optsmooth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimise smoothing parameter for a given tree and branch statistic — optsmooth","text":"Output `optimise`. $minimum contains optimal smoothing parameter","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/plot.gpgmrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Capitalized Title (ideally limited to 65 characters) — plot.gpgmrf","text":"","code":"plot.gpgmrf(f)"},{"path":"https://emvolz.github.io/cod/reference/plot.gpgmrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Capitalized Title (ideally limited to 65 characters) — plot.gpgmrf","text":"f","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/plot.gpgmrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Capitalized Title (ideally limited to 65 characters) — plot.gpgmrf","text":"","code":"##---- Should be DIRECTLY executable !! ---- ##-- ==>  Define data, use random, ##--  or standard data sets, see data().  ## The function is currently defined as function (f)  {     stopifnot(inherits(f, \"gpgmrf\"))     f2beta = f$coef     tr1 = f$data     class(tr1) <- \"phylo\"     fdf <- data.frame(node = 1:length(tr1$nodetimes), theta = f2beta)     gtr1 = ggtree::ggtree(tr1) %<+% fdf     gtr1 + aes(color = theta) + scale_color_gradient2(low = \"blue\",          mid = \"lightblue\", high = \"red\", midpoint = 0, limits = range(fdf$theta),          name = \"ψ\") + ggtree::theme_tree2() + ggtree::geom_tiplab()   } #> function (f)  #> { #>     stopifnot(inherits(f, \"gpgmrf\")) #>     f2beta = f$coef #>     tr1 = f$data #>     class(tr1) <- \"phylo\" #>     fdf <- data.frame(node = 1:length(tr1$nodetimes), theta = f2beta) #>     gtr1 = ggtree::ggtree(tr1) %<+% fdf #>     gtr1 + aes(color = theta) + scale_color_gradient2(low = \"blue\",  #>         mid = \"lightblue\", high = \"red\", midpoint = 0, limits = range(fdf$theta),  #>         name = \"ψ\") + ggtree::theme_tree2() + ggtree::geom_tiplab() #> } #> <environment: 0x55de6f33d290>"},{"path":"https://emvolz.github.io/cod/reference/plotclusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Plots a fit from `codls` and cluster assigment from `computeclusters` — plotclusters","title":"Plots a fit from `codls` and cluster assigment from `computeclusters` — plotclusters","text":"Plots fit `codls` cluster assigment `computeclusters`","code":""},{"path":"https://emvolz.github.io/cod/reference/plotclusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plots a fit from `codls` and cluster assigment from `computeclusters` — plotclusters","text":"","code":"plotclusters(f, clusterdf, ...)"},{"path":"https://emvolz.github.io/cod/reference/plotclusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plots a fit from `codls` and cluster assigment from `computeclusters` — plotclusters","text":"`codls` fit Output data frame `computeclusters`","code":""},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/print.gpgmrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A Capitalized Title (ideally limited to 65 characters) — print.gpgmrf","text":"","code":"print.gpgmrf(f)"},{"path":"https://emvolz.github.io/cod/reference/print.gpgmrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A Capitalized Title (ideally limited to 65 characters) — print.gpgmrf","text":"f","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://emvolz.github.io/cod/reference/print.gpgmrf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A Capitalized Title (ideally limited to 65 characters) — print.gpgmrf","text":"","code":"##---- Should be DIRECTLY executable !! ---- ##-- ==>  Define data, use random, ##--  or standard data sets, see data().  ## The function is currently defined as function (f)  {     stopifnot(inherits(f, \"gpgmrf\"))     cat(\" Genealogical placement GMRF model fit \\n\")     print(f$data)     cat(\"Range of coefficients: \\n\")     print(range(coef(f)))     cat(glue::glue(\"Precision parameter (tau): {f$tau} \\n\"))     cat(\"\\n\")     invisible(f)   } #> function (f)  #> { #>     stopifnot(inherits(f, \"gpgmrf\")) #>     cat(\" Genealogical placement GMRF model fit \\n\") #>     print(f$data) #>     cat(\"Range of coefficients: \\n\") #>     print(range(coef(f))) #>     cat(glue::glue(\"Precision parameter (tau): {f$tau} \\n\")) #>     cat(\"\\n\") #>     invisible(f) #> } #> <environment: 0x55de6f076928>"},{"path":"https://emvolz.github.io/cod/reference/rmsclo.html","id":null,"dir":"Reference","previous_headings":"","what":"Root mean square coalescent log odds — rmsclo","title":"Root mean square coalescent log odds — rmsclo","text":"summary statistic describes amount variation coalescent rates across lineages phylogenetic tree defined $$ \\sqrt{ \\sum_i l_i \\psi_i^2 / L }  $$ sum branches tree weighted branch length \\(l_i\\)  \\( L = \\sum_i l_i  \\)","code":""},{"path":"https://emvolz.github.io/cod/reference/rmsclo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Root mean square coalescent log odds — rmsclo","text":"","code":"rmsclo(f)"},{"path":"https://emvolz.github.io/cod/reference/rmsclo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Root mean square coalescent log odds — rmsclo","text":"f Fit `codls`","code":""},{"path":"https://emvolz.github.io/cod/reference/rmsclo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Root mean square coalescent log odds — rmsclo","text":"Numeric RMSCLO","code":""},{"path":"https://emvolz.github.io/cod/reference/tauprofile.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","text":"Evaluate loss function cod model across range tau (precision parameter) values","code":""},{"path":"https://emvolz.github.io/cod/reference/tauprofile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","text":"","code":"tauprofile(   tr,   logtaulb = -4,   logtauub = 35,   res = 11,   startpc = 75,   endpc = 100,   nobj = 100,   ipw = NULL,   ncpu = 1 )"},{"path":"https://emvolz.github.io/cod/reference/tauprofile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","text":"tr phylogenetic tree ape::phylo format logtaulb Lower bound precision parameteters logtauub Upper bound precision parameteters res Number tau values evaluate startpc initial per cent nodes tree counting root tips loss function evaluated endpc final per cent nodes tree counting root tips loss function evaluated nobj integer number points along tree loss function evaluated. Inf, use points startpc endpc, may slow. ipw Optional inverse probability weights sample","code":""},{"path":"https://emvolz.github.io/cod/reference/tauprofile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate the loss function of the cod model across a range of tau (precision parameter) values — tauprofile","text":"data frame containing loss function evaluated range tau values","code":""}]
